package main

import (
	"bufio"
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"os"
	"path"
	"runtime"
	"runtime/pprof"
	"sync"
	"time"
)

type MalwareURL struct {
	// id,dateadded,url,url_status,threat,tags,urlhaus_link,reporter
	ID        string `json:"id"`
	DateAdded string `json:"dateadded"`
	URL       string `json:"url"`
	URLStatus string `json:"url_status"`
	Threat    string `json:"threat"`
	Tags      string `json:"tags"`
	Source    string `json:"urlhaus_link"`
	Reporter  string `json:"reporter"`
}

const randomizeURLs = true
const onlineURLs = "https://urlhaus.abuse.ch/downloads/csv_online/"

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

// threadProfile is a profile of threads created by the program.
var threadProfile = pprof.Lookup("threadcreate")

func main() {
	pUrl := flag.String("url", onlineURLs, "URL to be processed")
	flag.Parse()
	url := *pUrl
	if url == "" {
		fmt.Fprintf(os.Stderr, "Error: empty URL!\n")
		return
	}

	filename := path.Base(url)
	fmt.Println("Checking if " + filename + " exists ...")
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		err := download(url, filename)
		if err != nil {
			panic(err)
		}
		fmt.Println(filename + " saved!")
	} else {
		fmt.Println(filename + " already exists!")
	}

	//Now we can process the file
	fmt.Println("Processing " + filename + " ...")

	//Remove the first 9 lines from the file

	file, err := os.Open(filename)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	// Create a scanner to read the file line by line
	scanner := bufio.NewScanner(file)

	// Create a variable to keep track of the line number
	lineNumber := 0

	// Create a variable to store the lines to keep
	var linesToKeep []string

	// Loop through the lines in the file
	for scanner.Scan() {
		// Increment the line number
		lineNumber++

		// If the line number is greater than 9, add the line to the linesToKeep slice
		if lineNumber > 9 {
			linesToKeep = append(linesToKeep, scanner.Text())
		}
	}

	// Check for any errors that occurred while scanning the file
	if err := scanner.Err(); err != nil {
		panic(err)
	}

	// Open the file for writing
	file, err = os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	// Write the lines to keep to the file
	for _, line := range linesToKeep {
		fmt.Fprintln(file, line)
	}

	fmt.Println("File cleaned")

	// Now we can process the CSV file and load each line of data into a MalwareURL struct

	f, err := os.Open(filename)
	if err != nil {
		log.Fatal("Unable to read input file "+filename, err)
	}
	defer f.Close()

	csvReader := csv.NewReader(f)
	records, err := csvReader.ReadAll()
	if err != nil {
		log.Fatal("Unable to parse file as CSV for "+filename, err)
	}

	// Convert the records into a slice of MalwareURL structs
	var malwareURLs []MalwareURL
	for _, record := range records {
		malwareURLs = append(malwareURLs, MalwareURL{
			ID:        record[0],
			DateAdded: record[1],
			URL:       record[2],
			URLStatus: record[3],
			Threat:    record[4],
			Tags:      record[5],
			Source:    record[6],
			Reporter:  record[7],
		})
	}

	if randomizeURLs {
		//Shuffle the array randomly
		fmt.Println("Randomizing the URLs ...")
		rand.Seed(time.Now().UnixNano())
		rand.Shuffle(len(malwareURLs), func(i, j int) { malwareURLs[i], malwareURLs[j] = malwareURLs[j], malwareURLs[i] })
	}

	//Now download the malware files from the hosts

	fmt.Println("Downloading malware files from hosts to ./malware ...")

	// define the number of goroutines to use.
	count := 10
	// add the number of goroutines to wait for.
	wg.Add(count)
	// log the number of threads created.
	log.Println("Before thread count : ", threadProfile.Count())

	// create the goroutines.
	for i := 0; i < count; i++ {
		go getMalwareFromHosts(malwareURLs[i*len(malwareURLs)/count : (i+1)*len(malwareURLs)/count])
	}

	// wait for the goroutines to finish.
	wg.Wait()

	// log the number of threads created.
	log.Println("After thread count : ", threadProfile.Count())
}

func init() {
	// set the number of CPUs to use.
	// By default, the number of CPUs is the number of CPUs on the machine.
	// Just to show we can change the number of CPUs
	// I have added this below command.
	runtime.GOMAXPROCS(runtime.NumCPU())
}

func getMalwareFromHosts(malwareURLs []MalwareURL) {

	// lock the current thread.
	runtime.LockOSThread()
	// defer the call to wg.Done().
	defer wg.Done()
	// sleep
	time.Sleep(time.Second * 2)

	for _, host := range malwareURLs {
		filename := path.Base(host.URL)
		if _, err := os.Stat("./malware/" + host.ID + "/" + filename); os.IsNotExist(err) {
			err := download(host.URL, "./malware/"+host.ID+"/"+filename)
			if err != nil {
				fmt.Println("Error downloading ", host.URL, " moving on...")
				continue
			}
			fmt.Println(filename + " saved!")
		} else {
			fmt.Println(filename + " already exists!")
		}
	}

	// sleep
	time.Sleep(time.Second * 2)

	// unlock the current thread.
	runtime.UnlockOSThread()
}

func download(url, filename string) (err error) {
	fmt.Println("Downloading ", url, " to ", filename)

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("GET ERROR: ", err)
		return err
	}
	defer resp.Body.Close()

	f, err := os.Create(filename)
	if err != nil {
		return
	}
	defer f.Close()
	_, err = io.Copy(f, resp.Body)

	return

}
